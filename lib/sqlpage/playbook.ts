import { ensureDir } from "jsr:@std/fs@^1";
import { dirname, join } from "jsr:@std/path@^1";
import { z } from "jsr:@zod/zod@4";
import { safeSourceText } from "../universal/content-acquisition.ts";
import { unsafeInterpolator } from "../universal/interpolate.ts";
import { notebooks } from "../universal/md-notebook.ts";
import { fbPartialsCollection } from "../universal/md-partial.ts";
import {
  mutatePlaybookCodeCells,
  pipedPlaybookCodeCellMutators,
  PlaybookCodeCell,
  PlaybookCodeCellMutator,
  playbooks,
  safeFrontmatter,
} from "../universal/md-playbook.ts";
import { forestToStatelessViews } from "../universal/path-tree-tabular.ts";
import { sqlPageConfSchema } from "./conf.ts";
import { enrichSqlDirective, SqlDirectiveCells } from "./directives.ts";
import * as interp from "./interpolate.ts";
import {
  enrichRoute,
  isRouteSupplier,
  PageRoute,
  resolvedRoutes,
} from "./route.ts";
import { sqlPagePathsFactory } from "./spp.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

export enum SourceRelativeTo {
  LocalFs = "fs",
  Module = "module",
}

const defaultFmSchema = z.object({
  siteName: z.string().optional(),
  "sqlpage-conf": sqlPageConfSchema.optional(),
}).catchall(z.unknown());

export type SqlPageFile = {
  readonly kind: "head_sql" | "tail_sql" | "sqlpage_file_upsert";
  readonly path: string; // relative path (e.g., "sql.d/head/001.sql", "admin/index.sql")
  contents: string; // file contents (comes from cell.source but will be mutated for interpolations)
  readonly lastModified?: Date; // optional timestamp (not used in DML; engine time is used)
  readonly cell?: PlaybookCodeCell<string>;
  readonly asErrorContents: (text: string, error: unknown) => string;
  readonly isAutoGenerated?: boolean;
  readonly isUnsafeInterpolatable?: boolean;
  readonly isInjectableCandidate?: boolean;
  error?: unknown;
  isInterpolated?: boolean;
  partialInjected?: Awaited<
    ReturnType<ReturnType<typeof fbPartialsCollection>["findInjectableForPath"]>
  >;
};

export function sqlPageFilesFactory() {
  function counter<Identifier>(identifier: Identifier, padValue = 4) {
    let value = -1;
    const incr = () => ++value;
    const next = () => String(incr()).padStart(padValue, "0");
    return { identifier, incr, next };
  }

  const sql = (
    path: string,
    contents: string,
    candidate?: Partial<SqlPageFile>,
  ): SqlPageFile => ({
    kind: candidate?.kind ?? "sqlpage_file_upsert",
    path,
    contents,
    asErrorContents: (text) => text.replaceAll(/^/gm, "-- "),
    ...candidate,
  });

  const json = (
    path: string,
    contents: string,
    candidate?: Partial<SqlPageFile>,
  ): SqlPageFile => ({
    kind: candidate?.kind ?? "sqlpage_file_upsert",
    path,
    contents,
    asErrorContents: (text, error) => JSON.stringify({ text, error }),
    ...candidate,
  });

  return { sql, json, counter };
}

export class RoutesBuilder {
  #resolved?: Awaited<ReturnType<typeof resolvedRoutes>>;

  constructor(readonly encountered: PageRoute[] = []) {
  }

  encounter(pr: PageRoute) {
    this.encountered.push(pr);
  }

  async resolved() {
    if (!this.#resolved) {
      this.#resolved = await resolvedRoutes(this.encountered);
    }
    return this.#resolved;
  }
}

export const enrichFrontmatter: PlaybookCodeCellMutator<string> = (
  cell,
  { pb },
) => {
  if ("frontmatter" in cell) return;
  (cell as Any).frontmatter = pb.notebook.fm;
};

export class SqlPagePlaybook {
  protected readonly pbCodeCellMutators: PlaybookCodeCellMutator<
    string
  >[] = [];
  protected pipedDocCCMutators = pipedPlaybookCodeCellMutators(
    this.pbCodeCellMutators,
  );
  protected constructor() {
    this.setupPlaybookCodeCellMutators();
  }

  withPlaybookCodeCellMutator(dcce: PlaybookCodeCellMutator<string>) {
    this.pbCodeCellMutators.push(dcce);
    this.pipedDocCCMutators = pipedPlaybookCodeCellMutators(
      this.pbCodeCellMutators,
    );
  }

  setupPlaybookCodeCellMutators() {
    // the order of these mutators matter!
    this.withPlaybookCodeCellMutator(enrichSqlDirective);
    this.withPlaybookCodeCellMutator(enrichRoute);
    this.withPlaybookCodeCellMutator(enrichFrontmatter);
  }

  async *notebooks(opts: { md: string[]; srcRelTo: SourceRelativeTo }) {
    const sources = async function* () {
      for await (const md of opts.md) {
        const safeMdSrc = await safeSourceText(md, opts.srcRelTo);
        if (safeMdSrc.nature == "error") {
          console.error(safeMdSrc);
          continue;
        }
        yield {
          provenance: typeof safeMdSrc.source === "string"
            ? safeMdSrc.source
            : safeMdSrc.source.href,
          content: safeMdSrc.text,
        };
      }
    };
    for await (
      const safeNB of safeFrontmatter(defaultFmSchema, notebooks(sources()))
    ) {
      if (safeNB.zodParseResult.success) {
        yield safeNB.notebook;
      } else {
        console.error(safeNB.notebook.provenance);
        console.error(z.prettifyError(safeNB.zodParseResult.error));
      }
    }
  }

  async *sqlPageCodebooks(opts: { md: string[]; srcRelTo: SourceRelativeTo }) {
    return yield* mutatePlaybookCodeCells(
      this.pipedDocCCMutators,
      playbooks(this.notebooks(opts), { kind: "hr" }),
    );
  }

  async *codeCells(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
    directives: SqlDirectiveCells,
  ) {
    const spBooks = await Array.fromAsync(this.sqlPageCodebooks(opts));
    const EXTRACTED = ".extractedInCodeCells" as const;
    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code") {
          if (directives.register(cell)) {
            (cell as Any)[EXTRACTED] = true;
          }
        }
      }
    }

    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code" && !(EXTRACTED in cell)) {
          yield cell;
        }
      }

      const { notebook: nb } = spnb;
      if (nb.issues.length) {
        yield {
          kind: "code",
          language: "json",
          source: JSON.stringify(nb.issues, null, 2),
          info: "NOTEBOOK_ISSUES",
          attrs: { issues: nb.issues },
          provenance: nb.provenance,
        } satisfies PlaybookCodeCell<string>;
      }
    }
  }

  prepareState() {
    const partials = fbPartialsCollection();
    const directives = new SqlDirectiveCells(partials);
    const routes = new RoutesBuilder();
    const spp = sqlPagePathsFactory();
    return { directives, routes, spp, partials };
  }

  async *rawSqlPageFileEntries(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
    state: ReturnType<SqlPagePlaybook["prepareState"]>,
  ): AsyncGenerator<SqlPageFile> {
    const { routes, directives } = state;
    const { sql: sqlSPF, json: jsonSPF, counter } = sqlPageFilesFactory();

    const codeCells = await Array.fromAsync(
      this.codeCells(opts, directives),
    );

    const headCount = counter("head");
    for (const head of directives.heads) {
      yield sqlSPF(`sql.d/head/${headCount.next()}.sql`, head.source, {
        kind: "head_sql",
        cell: head,
      });
    }

    for await (const cell of codeCells) {
      switch (cell.language) {
        case "json": {
          if (cell.info && cell.info === "NOTEBOOK_ISSUES") {
            yield jsonSPF(
              `spry.d/issues/${cell.provenance}.auto.json`,
              cell.source,
              { cell, isAutoGenerated: true },
            );
          }
          break;
        }
        case "sql": {
          if (!cell.info) {
            console.warn(
              `sql fenced block found without INFO on line ${cell.startLine} of ${cell.provenance}`,
            );
            continue;
          }

          const { info: path } = cell;
          yield sqlSPF(path, cell.source, {
            cell,
            isUnsafeInterpolatable: true,
            isInjectableCandidate: true,
          });

          if (Object.entries(cell.attrs).length) {
            if (isRouteSupplier(cell.attrs)) {
              routes.encounter(cell.attrs.route as PageRoute);
            }
            yield jsonSPF(
              `spry.d/auto/resource/${path}.auto.json`,
              JSON.stringify(this.dropUndef(cell.attrs), null, 2),
              { cell, isAutoGenerated: true },
            );
          }
          break;
        }
      }
    }

    for (const p of directives.partials.catalog.values()) {
      yield sqlSPF(
        `spry.d/auto/partial/${p.identity}.auto.sql`,
        `-- ${JSON.stringify(p)}\n${p.source}`,
        { isAutoGenerated: true },
      );
    }

    const tailCount = counter("tail");
    for (const tail of directives.tails) {
      yield sqlSPF(`sql.d/tail/${tailCount.next()}.sql`, tail.source, {
        kind: "tail_sql",
        cell: tail,
      });
    }

    const { forest, breadcrumbs, edges, serializers } = await routes.resolved();

    yield sqlSPF(
      `spry.d/auto/route/tree.auto.txt`,
      serializers.asciiTreeText({
        showPath: true,
        includeCounts: true,
      }),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/forest.auto.json`,
      JSON.stringify(forest.roots, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/forest.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(forest.schemas.forest), null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/breadcrumbs.auto.json`,
      JSON.stringify(breadcrumbs.crumbs, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/breadcrumbs.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(breadcrumbs.schema), null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/edges.auto.json`,
      JSON.stringify(edges.edges, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/edges.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(edges.schemas.edges), null, 2),
      { isAutoGenerated: true },
    );

    const sv = forestToStatelessViews(forest, { viewPrefix: "navigation_" });
    yield sqlSPF(`sql.d/tail/navigation.auto.sql`, sv.sql, {
      kind: "tail_sql",
    });
  }

  interpolationCtx(
    _opts: { md: string[] },
    state: ReturnType<SqlPagePlaybook["prepareState"]>,
  ) {
    const { directives, routes } = state;
    const pagination = {
      active: undefined as undefined | ReturnType<typeof interp.pagination>,
      prepare: interp.pagination,
      debug: `/* \${paginate("tableOrViewName")} not called yet*/`,
      limit: `/* \${paginate("tableOrViewName")} not called yet*/`,
      navigation: `/* \${paginate("tableOrViewName")} not called yet*/`,
      navWithParams: (..._extraQueryParams: string[]) =>
        `/* \${paginate("tableOrViewName")} not called yet*/`,
    };
    return {
      directives,
      routes,
      pagination,
      absUrlQuoted: interp.absUrlQuoted,
      absUrlUnquoted: interp.absUrlUnquoted,
      absUrlUnquotedEncoded: interp.absUrlUnquotedEncoded,
      absUrlQuotedEncoded: interp.absUrlQuotedEncoded,
      sitePrefixed: interp.absUrlQuoted,
      paginate: (tableOrViewName: string, whereSQL?: string) => {
        const pn = interp.pagination({ tableOrViewName, whereSQL });
        pagination.active = pn;
        pagination.debug = pn.debugVars();
        pagination.limit = pn.limit();
        pagination.navigation = pn.navigation();
        pagination.navWithParams = pn.navigation;
        return pagination.active.init();
      },
    };
  }

  async *finalSqlPageFileEntries(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
    state: ReturnType<SqlPagePlaybook["prepareState"]>,
  ) {
    const { directives } = state;
    const baseCtx = this.interpolationCtx(opts, state);
    const unsafeInterp = unsafeInterpolator(baseCtx);

    for await (const spf of this.rawSqlPageFileEntries(opts, state)) {
      const { path } = spf;

      try {
        const layout = spf.isInjectableCandidate
          ? directives.partials.findInjectableForPath(path)
          : undefined;

        if (spf.isUnsafeInterpolatable) {
          const source = layout?.injection?.wrap(spf.contents) ?? spf.contents;

          // NOTE: This is intentionally unsafe. Do not feed untrusted content.
          // Assume you're treating code cell blocks as fully trusted source code.
          const mutated = await unsafeInterp.interpolate(source, {
            pagination: baseCtx.pagination,
            paginate: baseCtx.paginate,
            ...spf.cell?.attrs,
            ...spf,
            partial: async (
              name: string,
              partialLocals?: Record<string, unknown>,
            ) => {
              const found = directives.partial(name);
              if (found) {
                const { content: partial, interpolate, locals } = await found
                  .content({
                    ...partialLocals,
                    ...spf.cell?.attrs,
                    ...spf,
                  });
                if (!interpolate) return partial;
                return await unsafeInterp.interpolate(partial, locals, [{
                  template: partial,
                }]);
              } else {
                return `/* partial '${name}' not found */`;
              }
            },
          });

          if (mutated !== spf.contents) {
            spf.contents = String(mutated);
            spf.isInterpolated = true;
          }
        } else if (layout && layout.injection) {
          spf.contents = layout.injection.wrap(spf.contents);
        }

        if (layout) spf.partialInjected = layout;
        yield spf;
      } catch (error) {
        spf.error = error;
        yield {
          ...spf,
          contents: spf.asErrorContents(
            `finalSqlPageFileEntries error: ${String(error)}\n*****\n${
              JSON.stringify({ ctx: unsafeInterp.ctx, spf }, null, 2)
            }`,
            error,
          ),
        };
      }
    }
  }

  async materializeContent(
    opts: { fs: string; path: string; contents: string },
  ) {
    const { fs, path, contents } = opts;
    const absPath = join(fs, path);
    await ensureDir(dirname(absPath));
    await Deno.writeTextFile(absPath, contents);
    return absPath;
  }

  async *materializeFs(
    opts: { md: string[]; srcRelTo: SourceRelativeTo; fs: string },
  ) {
    for await (
      const spf of this.finalSqlPageFileEntries(opts, this.prepareState())
    ) {
      const absPath = this.materializeContent({
        fs: opts.fs,
        path: spf.path,
        contents: spf.contents,
      });
      yield { ...spf, absPath };
    }
  }

  /**
   * Build DML statements to upsert files into a SQLPage virtual-files table.
   * dialect "sqlite":
   *   INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('…','…', CURRENT_TIMESTAMP)
   *   ON CONFLICT(path) DO UPDATE
   *     SET contents = excluded.contents,
   *         last_modified = CURRENT_TIMESTAMP
   *     WHERE sqlpage_files.contents <> excluded.contents;
   *
   * Returns one object per file, tagged with kind: "sqlpage_file_insert".
   * On conflict when contents differ, last_modified is set by the SQL engine (CURRENT_TIMESTAMP).
   * If contents are identical, the row is left unchanged.
   */
  async sqlPageFilesUpsertDML(
    dialect: "sqlite",
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      includeSqlPageFilesTable?: boolean;
    },
  ) {
    if (dialect !== "sqlite") {
      throw new Error(`Unsupported dialect: ${dialect}`);
    }
    if (opts.includeSqlPageFilesTable) {
      `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`;
    }

    const esc = (s: string) => s.replace(/'/g, "''");
    const state = this.prepareState();
    const list = await Array.fromAsync(
      this.finalSqlPageFileEntries(opts, state),
    );

    // Deterministic order: heads → non-head/tail → tails
    return [
      opts.includeSqlPageFilesTable
        ? `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`
        : "-- sqlpage_files DDL not requested",
      ...list.filter((e) => e.kind === "head_sql").map((spf) => spf.contents),
      ...list.filter((e) => e.kind === "sqlpage_file_upsert").map((f) => {
        const pathLit = `'${esc(f.path)}'`;
        const bodyLit = `'${esc(f.contents)}'`;
        return `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES (${pathLit}, ${bodyLit}, CURRENT_TIMESTAMP) ` +
          `ON CONFLICT(path) DO UPDATE SET contents = excluded.contents, last_modified = CURRENT_TIMESTAMP ` +
          `WHERE sqlpage_files.contents <> excluded.contents;`;
      }), // pages, shells, partials, etc.
      ...list.filter((e) => e.kind === "tail_sql").map((spf) => spf.contents),
    ];
  }

  // Utility: drop undefined recursively
  protected dropUndef<T extends Record<string, unknown>>(obj: T): T {
    const out: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(obj)) {
      if (v === undefined) continue;
      if (v && typeof v === "object" && !Array.isArray(v)) {
        const nested = this.dropUndef(v as Record<string, unknown>);
        if (Object.keys(nested).length > 0) out[k] = nested;
      } else {
        out[k] = v;
      }
    }
    return out as T;
  }

  // Produces the exact JSON object you can write to sqlpage/sqlpage.json
  sqlPageConf(conf: z.infer<typeof sqlPageConfSchema>) {
    // Start from a shallow clone
    const out: Record<string, unknown> = { ...conf };

    // Flatten nested OIDC if provided
    if (conf.oidc) {
      const { issuer_url, client_id, client_secret, scopes, redirect_path } =
        conf.oidc;
      // Only set flat keys if not already set at top level
      if (issuer_url && out.oidc_issuer_url === undefined) {
        out.oidc_issuer_url = issuer_url;
      }
      if (client_id && out.oidc_client_id === undefined) {
        out.oidc_client_id = client_id;
      }
      if (client_secret && out.oidc_client_secret === undefined) {
        out.oidc_client_secret = client_secret;
      }
      if (scopes !== undefined) out.oidc_scopes = scopes; // SQLPage ignores unknowns; keeping for future
      if (redirect_path !== undefined) out.oidc_redirect_path = redirect_path;
      delete out.oidc;
    }

    // Clean undefineds
    return this.dropUndef(out);
  }

  static instance() {
    return new SqlPagePlaybook();
  }
}
