import { Command, EnumType } from "jsr:@cliffy/command@1.0.0-rc.8";
import { HelpCommand } from "jsr:@cliffy/command@1.0.0-rc.8/help";
import {
  bold,
  brightYellow,
  cyan,
  gray,
  green,
  red,
  yellow,
} from "jsr:@std/fmt@^1/colors";
import { ensureDir } from "jsr:@std/fs@^1";
import { dirname, globToRegExp, join, relative } from "jsr:@std/path@^1";
import { basename } from "node:path";
import * as taskCLI from "../task/cli.ts";
import { collectAsyncGenerated } from "../universal/collectable.ts";
import { SourceRelativeTo } from "../universal/content-acquisition.ts";
import { ColumnDef, ListerBuilder } from "../universal/lister-tabular-tui.ts";
import { TreeLister } from "../universal/lister-tree-tui.ts";
import { executionSubplan } from "../universal/task.ts";
import { sqlPageConf } from "./conf.ts";
import {
  normalizeSPC,
  SqlPageContent,
  sqlPageFilesUpsertDML,
} from "./content.ts";
import { SqlPagePlaybook, sqlPagePlaybookState } from "./playbook.ts";
import { isRouteSupplier } from "./route.ts";

export type LsCommandRow = SqlPageContent & {
  name: string;
  notebook: string;
  flags: {
    isRouteSupplier: boolean;
    isPartialInjected: boolean;
    isAutoGenerated: boolean;
    isError: boolean;
    isInterpolated: boolean;
  };
  error?: unknown;
};

const flagsFrom = (spc: SqlPageContent) => {
  switch (spc.kind) {
    case "head_sql":
    case "tail_sql":
      return {
        isAutoGenerated: false,
        isInterpolated: false,
        isError: false,
        isPartialInjected: false,
        isRouteSupplier: false,
      };

    case "sqlpage_file_upsert":
      return {
        isAutoGenerated: spc.isAutoGenerated ? true : false,
        isInterpolated: spc.isInterpolated ? true : false,
        isError: spc.error ? true : false,
        isPartialInjected: spc.partialInjected ? true : false,
        isRouteSupplier: isRouteSupplier(spc.cell?.attrs) ? true : false,
      };
  }
};

/**
 * Ensure all ancestor directories exist as rows.
 * - items: your existing rows (any shape)
 * - pathOf: how to extract a path string from a row
 * - makeRow: how to create a row for a missing directory, given its path
 * - isFile (optional): how to decide if a path is a file; defaults to "last segment contains a dot"
 */
export function upsertMissingAncestors<T>(
  items: T[],
  pathOf: (item: T) => string,
  makeRow: (dirPath: string) => T,
  isFile: (path: string) => boolean = (p) => {
    const segs = p.split("/").filter(Boolean);
    return segs.length > 0 && segs[segs.length - 1].includes(".");
  },
): T[] {
  const seen = new Set(items.map(pathOf));
  const out = [...items];

  for (const item of items) {
    const p = pathOf(item);
    const segs = p.split("/").filter(Boolean);
    const max = isFile(p) ? segs.length - 1 : segs.length;

    for (let i = 1; i <= max; i++) {
      const dirPath = segs.slice(0, i).join("/");
      if (!seen.has(dirPath)) {
        out.push(makeRow(dirPath));
        seen.add(dirPath);
      }
    }
  }
  return out;
}

export class CLI {
  constructor(readonly spn = SqlPagePlaybook.instance()) {
  }

  lsColorPathField<Row extends LsCommandRow>(
    header: string,
  ): Partial<ColumnDef<Row, string>> {
    return {
      header,
      format: (supplied) => {
        const p = relative(Deno.cwd(), supplied);
        const i = p.lastIndexOf("/");
        return i < 0 ? bold(p) : gray(p.slice(0, i + 1)) + bold(p.slice(i + 1));
      },
      rules: [{
        when: (_v, r) =>
          "error" in r
            ? ((r.error ? String(r.error)?.trim().length ?? 0 : 0) > 0)
            : false,
        color: red,
      }],
    };
  }

  lsNaturePathField<Row extends LsCommandRow>(): Partial<
    ColumnDef<Row, string>
  > {
    const lscpf = this.lsColorPathField("Path");
    return {
      ...lscpf,
      rules: [...(lscpf.rules ? lscpf.rules : []), {
        when: (_v, r) => r.kind === "sqlpage_file_upsert" && !r.isAutoGenerated,
        color: brightYellow,
      }],
    };
  }

  lsNatureField<Row extends LsCommandRow>(): Partial<
    ColumnDef<Row, Row["kind"]>
  > {
    return {
      header: "Nature",
      format: (v) =>
        v === "head_sql"
          ? green(v)
          : v === "tail_sql"
          ? yellow(v)
          : v === "sqlpage_file_upsert"
          ? brightYellow(v)
          : cyan(v),
    };
  }

  lsFlagsField<Row extends LsCommandRow>():
    | Partial<ColumnDef<Row, Row["flags"]>>
    | undefined {
    return {
      header: "Flags",
      defaultColor: gray,
      // deno-fmt-ignore
      format: (v) =>
        `${brightYellow(v.isInterpolated ? "I" : " ")} ${yellow(v.isRouteSupplier ? "R" : " ")} ${v.isAutoGenerated ? "A" : " "} ${v.isError ? "E" : " "} ${v.isPartialInjected ? "P" : " "}`,
    };
  }

  async ls(
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      conf?: boolean;
      tree?: boolean;
    },
  ) {
    const { items } = await collectAsyncGenerated(
      this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }),
    );
    let spfe = items.map((spf) => ({
      ...spf,
      name: basename(spf.path),
      flags: flagsFrom(spf),
      notebook: spf.cell?.provenance ?? "",
    }));

    if (opts.tree) {
      spfe = upsertMissingAncestors<LsCommandRow>(
        spfe.map((spf) => ({
          ...spf,
          path: relative(Deno.cwd(), spf.path),
        })),
        (r) => r.path,
        (path) => ({
          // deno-lint-ignore no-explicit-any
          kind: "" as any,
          path,
          contents: "virtual",
          asErrorContents: () => "virtual",
          name: basename(path),
          notebook: "",
          flags: {
            isAutoGenerated: false,
            isInterpolated: false,
            isError: false,
            isPartialInjected: false,
            isRouteSupplier: false,
          },
        }),
      );

      const base = new ListerBuilder<LsCommandRow>()
        .declareColumns("kind", "name", "flags", "error", "notebook")
        .from(spfe)
        .field("name", "name", this.lsNaturePathField())
        .field("kind", "kind", this.lsNatureField())
        .field("flags", "flags", this.lsFlagsField())
        .field("error", "error", { header: "Err" })
        .field("notebook", "notebook", this.lsColorPathField("Notebook"))
        // IMPORTANT: make the tree column first so glyphs appear next to it
        .select("name", "kind", "flags", "error", "notebook");
      const tree = TreeLister
        .wrap(base)
        .from(spfe)
        .byPath({ pathKey: "path", separator: "/" })
        .treeOn("name");
      await tree.ls(true);
    } else {
      await new ListerBuilder<LsCommandRow>()
        .declareColumns("kind", "path", "flags", "notebook", "error")
        .from(spfe)
        .field("kind", "kind", this.lsNatureField())
        .field("path", "path", this.lsNaturePathField())
        .field("flags", "flags", this.lsFlagsField())
        .field("error", "error", { header: "Err" })
        .field("notebook", "notebook", this.lsColorPathField("Notebook"))
        .sortBy("path").sortDir("asc")
        .build()
        .ls(true);
    }
  }

  async cat(
    opts: { md: string[]; srcRelTo: SourceRelativeTo; glob: string[] },
  ) {
    const matchesAnyGlob = (path: string) =>
      opts.glob.some((g) =>
        globToRegExp(g, { extended: true, globstar: true }).test(path)
      );

    const { items } = await collectAsyncGenerated(
      this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }),
    );

    for (const spf of items) {
      if (matchesAnyGlob(spf.path)) {
        console.log(spf.contents);
      }
    }
  }

  async *materializeFs(
    opts: { md: string[]; srcRelTo: SourceRelativeTo; fs: string },
  ) {
    const { fs } = opts;
    for await (
      const spf of normalizeSPC(this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }))
    ) {
      const absPath = join(fs, spf.path);
      await ensureDir(dirname(absPath));
      await Deno.writeTextFile(absPath, spf.contents);
      yield { ...spf, absPath };
    }
  }

  command(name = "spry.ts") {
    // Enum type with enum.
    const srcRelTo = new EnumType(SourceRelativeTo);
    const mdOpt = [
      "-m, --md <mdPath:string>",
      "Use the given Markdown source(s), multiple allowed",
      {
        required: true,
        collect: true,
        default: ["Spryfile.md"],
      },
    ] as const;
    const srcRelToOpt = [
      "--src-rel-to <relative-to:sourceRelTo>",
      "When relative paths are used, what are they relative to?",
      {
        default: SourceRelativeTo.LocalFs,
      },
    ] as const;

    return new Command()
      .name(name)
      .version("0.1.0")
      .description(
        "SQLPage Markdown Notebook: emit SQL package, write sqlpage.json, or materialize filesystem.",
      )
      .command("help", new HelpCommand().global())
      .command(
        "spc",
        new Command() // Emit SQL package (sqlite) to stdout; accepts md path
          .description("SQLPage Content (spc) CLI")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option(
            "-p, --package",
            "Emit SQL package (sqlite) to stdout from the given markdown path.",
            { conflicts: ["fs"] },
          )
          // Materialize files to a target directory
          .option(
            "--fs <srcHome:string>",
            "Materialize SQL files under this directory.",
            { conflicts: ["package"] },
          )
          // Write sqlpage.json to the given path
          .option(
            "-c, --conf <confPath:string>",
            "Write sqlpage.json to this path (generated from frontmatter sqlpage-conf).",
          )
          .option("--verbose", "Emit information messages")
          .action(async (opts) => {
            // If --fs is present, materialize files under that root
            if (typeof opts.fs === "string" && opts.fs.length > 0) {
              const generated = await Array.fromAsync(
                this.materializeFs({
                  // not sure why this mapping is needed, Cliffy seems to not type `default` for `collect`ed arrays properly?
                  md: opts.md.map((f) => String(f)),
                  srcRelTo: opts.srcRelTo,
                  fs: opts.fs,
                }),
              );
              if (opts.verbose) {
                generated.forEach((f) => console.log(f.absPath));
              }
            }

            // If -p/--package is present (i.e., user requested SQL package), emit to stdout
            if (opts.package) {
              for (
                const chunk of await sqlPageFilesUpsertDML(
                  this.spn.sqlPageFiles({
                    mdSources: opts.md.map((f) => String(f)),
                    srcRelTo: opts.srcRelTo,
                    state: sqlPagePlaybookState(),
                  }),
                  {
                    dialect: "sqlite",
                    includeSqlPageFilesTable: true,
                  },
                )
              ) {
                console.log(chunk);
              }
            }

            // If --conf is present, write sqlpage.json
            if (opts.conf) {
              let emitted = 0, encountered = 0;
              const pp = await this.spn.populateContent({
                mdSources: opts.md.map((f) => String(f)),
                srcRelTo: opts.srcRelTo,
                state: sqlPagePlaybookState(),
              });
              for (const pb of pp.state.directives.playbooks) {
                encountered++;
                const { notebook: nb } = pb;
                if (nb.fm["sqlpage-conf"]) {
                  const json = sqlPageConf(nb.fm["sqlpage-conf"]);
                  // "web_root" should only be specified for `--fs`
                  // otherwise the directory won't exist
                  if (opts.package) delete json["web_root"];
                  await ensureDir(dirname(opts.conf));
                  await Deno.writeTextFile(
                    opts.conf,
                    JSON.stringify(json, null, 2),
                  );
                  if (opts.verbose) {
                    console.log(opts.conf);
                  }
                  emitted++;
                  break; // only pick from the first file
                }
              }
              if (emitted == 0) {
                console.warn(
                  `Encountered ${encountered} playbook(s) but no "sqlpage-conf" found in any frontmatter.`,
                );
              }
            }
          })
          .command("ls", "List SQLPage file entries")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("-t, --tree", "Show as tree")
          .action((opts) =>
            this.ls({
              ...opts,
              md: opts.md.map((f) => String(f)),
            })
          )
          .command("cat", "Concatenate SQLPage file contents")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("-g, --glob <path:string>", "Path glob(s) to target", {
            required: true,
            collect: true,
          })
          .action((opts) =>
            this.cat({
              ...opts,
              md: opts.md.map((f) => String(f)),
            })
          ),
      )
      .command(
        "task",
        new Command() // Emit SQL package (sqlite) to stdout; accepts md path
          .description("Spry Task CLI")
          .type("sourceRelTo", srcRelTo)
          .arguments("<taskId>")
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("--verbose", "Emit information messages")
          .action(async (opts, taskId) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            taskCLI.executeTasks(
              executionSubplan(pp.executionPlan, [taskId]),
              opts.verbose ? "rich" : false,
            );
          })
          .command("ls", "List SQLPage file entries")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option(
            "-c, --content",
            "List CONTENT cells in addition to executables",
          )
          .action(async (opts) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            taskCLI.ls(
              opts.content
                ? pp.state.directives.tasks
                : pp.state.directives.tasks.filter((t) =>
                  t.taskDirective.nature === "TASK"
                ),
            );
          }),
      );
  }

  async run(argv: string[] = Deno.args, name = "spry.ts") {
    await this.command(name).parse(argv);
  }

  static instance() {
    return new CLI();
  }
}
