import { Command, EnumType } from "jsr:@cliffy/command@1.0.0-rc.8";
import { HelpCommand } from "jsr:@cliffy/command@1.0.0-rc.8/help";
import {
  bold,
  brightYellow,
  cyan,
  gray,
  green,
  red,
  yellow,
} from "jsr:@std/fmt@^1/colors";
import { ensureDir } from "jsr:@std/fs@^1";
import {
  basename,
  dirname,
  globToRegExp,
  join,
  relative,
} from "jsr:@std/path@^1";
import * as taskCLI from "../task/cli.ts";
import { collectAsyncGenerated } from "../universal/collectable.ts";
import { SourceRelativeTo } from "../universal/content-acquisition.ts";
import { doctor } from "../universal/doctor.ts";
import { eventBus } from "../universal/event-bus.ts";
import { ColumnDef, ListerBuilder } from "../universal/lister-tabular-tui.ts";
import { TreeLister } from "../universal/lister-tree-tui.ts";
import { executionPlan, executionSubplan } from "../universal/task.ts";
import { SidecarOpts, watcher, WatcherEvents } from "../universal/watcher.ts";
import { sqlPageConf } from "./conf.ts";
import {
  normalizeSPC,
  SqlPageContent,
  sqlPageFilesUpsertDML,
} from "./content.ts";
import { SqlPagePlaybook, sqlPagePlaybookState } from "./playbook.ts";
import { isRouteSupplier } from "./route.ts";

export type LsCommandRow = SqlPageContent & {
  name: string;
  notebook: string;
  flags: {
    isRouteSupplier: boolean;
    isPartialInjected: boolean;
    isAutoGenerated: boolean;
    isError: boolean;
    isInterpolated: boolean;
  };
  error?: unknown;
};

const flagsFrom = (spc: SqlPageContent) => {
  switch (spc.kind) {
    case "head_sql":
    case "tail_sql":
      return {
        isAutoGenerated: false,
        isInterpolated: false,
        isError: false,
        isPartialInjected: false,
        isRouteSupplier: false,
      };

    case "sqlpage_file_upsert":
      return {
        isAutoGenerated: spc.isAutoGenerated ? true : false,
        isInterpolated: spc.isInterpolated ? true : false,
        isError: spc.error ? true : false,
        isPartialInjected: spc.partialInjected ? true : false,
        isRouteSupplier: isRouteSupplier(spc.cell?.attrs) ? true : false,
      };
  }
};

/**
 * Ensure all ancestor directories exist as rows.
 * - items: your existing rows (any shape)
 * - pathOf: how to extract a path string from a row
 * - makeRow: how to create a row for a missing directory, given its path
 * - isFile (optional): how to decide if a path is a file; defaults to "last segment contains a dot"
 */
export function upsertMissingAncestors<T>(
  items: T[],
  pathOf: (item: T) => string,
  makeRow: (dirPath: string) => T,
  isFile: (path: string) => boolean = (p) => {
    const segs = p.split("/").filter(Boolean);
    return segs.length > 0 && segs[segs.length - 1].includes(".");
  },
): T[] {
  const seen = new Set(items.map(pathOf));
  const out = [...items];

  for (const item of items) {
    const p = pathOf(item);
    const segs = p.split("/").filter(Boolean);
    const max = isFile(p) ? segs.length - 1 : segs.length;

    for (let i = 1; i <= max; i++) {
      const dirPath = segs.slice(0, i).join("/");
      if (!seen.has(dirPath)) {
        out.push(makeRow(dirPath));
        seen.add(dirPath);
      }
    }
  }
  return out;
}

export class CLI {
  constructor(readonly spn = SqlPagePlaybook.instance()) {
  }

  lsColorPathField<Row extends LsCommandRow>(
    header: string,
  ): Partial<ColumnDef<Row, string>> {
    return {
      header,
      format: (supplied) => {
        const p = relative(Deno.cwd(), supplied);
        const i = p.lastIndexOf("/");
        return i < 0 ? bold(p) : gray(p.slice(0, i + 1)) + bold(p.slice(i + 1));
      },
      rules: [{
        when: (_v, r) =>
          "error" in r
            ? ((r.error ? String(r.error)?.trim().length ?? 0 : 0) > 0)
            : false,
        color: red,
      }],
    };
  }

  lsNaturePathField<Row extends LsCommandRow>(): Partial<
    ColumnDef<Row, string>
  > {
    const lscpf = this.lsColorPathField("Path");
    return {
      ...lscpf,
      rules: [...(lscpf.rules ? lscpf.rules : []), {
        when: (_v, r) => r.kind === "sqlpage_file_upsert" && !r.isAutoGenerated,
        color: brightYellow,
      }],
    };
  }

  lsNatureField<Row extends LsCommandRow>(): Partial<
    ColumnDef<Row, Row["kind"]>
  > {
    return {
      header: "Nature",
      format: (v) =>
        v === "head_sql"
          ? green(v)
          : v === "tail_sql"
          ? yellow(v)
          : v === "sqlpage_file_upsert"
          ? brightYellow(v)
          : cyan(v),
    };
  }

  lsFlagsField<Row extends LsCommandRow>():
    | Partial<ColumnDef<Row, Row["flags"]>>
    | undefined {
    return {
      header: "Flags",
      defaultColor: gray,
      // deno-fmt-ignore
      format: (v) =>
        `${brightYellow(v.isInterpolated ? "I" : " ")} ${yellow(v.isRouteSupplier ? "R" : " ")} ${v.isAutoGenerated ? "A" : " "} ${v.isError ? "E" : " "} ${v.isPartialInjected ? "P" : " "}`,
    };
  }

  async ls(
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      conf?: boolean;
      tree?: boolean;
    },
  ) {
    const { items } = await collectAsyncGenerated(
      this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }),
    );
    let spfe = items.map((spf) => ({
      ...spf,
      name: basename(spf.path),
      flags: flagsFrom(spf),
      notebook: spf.cell?.provenance ?? "",
    }));

    if (opts.tree) {
      spfe = upsertMissingAncestors<LsCommandRow>(
        spfe.map((spf) => ({
          ...spf,
          path: relative(Deno.cwd(), spf.path),
        })),
        (r) => r.path,
        (path) => ({
          // deno-lint-ignore no-explicit-any
          kind: "" as any,
          path,
          contents: "virtual",
          asErrorContents: () => "virtual",
          name: basename(path),
          notebook: "",
          flags: {
            isAutoGenerated: false,
            isInterpolated: false,
            isError: false,
            isPartialInjected: false,
            isRouteSupplier: false,
          },
        }),
      );

      const base = new ListerBuilder<LsCommandRow>()
        .declareColumns("kind", "name", "flags", "error", "notebook")
        .from(spfe)
        .field("name", "name", this.lsNaturePathField())
        .field("kind", "kind", this.lsNatureField())
        .field("flags", "flags", this.lsFlagsField())
        .field("error", "error", { header: "Err" })
        .field("notebook", "notebook", this.lsColorPathField("Notebook"))
        // IMPORTANT: make the tree column first so glyphs appear next to it
        .select("name", "kind", "flags", "error", "notebook");
      const tree = TreeLister
        .wrap(base)
        .from(spfe)
        .byPath({ pathKey: "path", separator: "/" })
        .treeOn("name");
      await tree.ls(true);
    } else {
      await new ListerBuilder<LsCommandRow>()
        .declareColumns("kind", "path", "flags", "notebook", "error")
        .from(spfe)
        .field("kind", "kind", this.lsNatureField())
        .field("path", "path", this.lsNaturePathField())
        .field("flags", "flags", this.lsFlagsField())
        .field("error", "error", { header: "Err" })
        .field("notebook", "notebook", this.lsColorPathField("Notebook"))
        .sortBy("path").sortDir("asc")
        .build()
        .ls(true);
    }
  }

  async cat(
    opts: { md: string[]; srcRelTo: SourceRelativeTo; glob: string[] },
  ) {
    const matchesAnyGlob = (path: string) =>
      opts.glob.some((g) =>
        globToRegExp(g, { extended: true, globstar: true }).test(path)
      );

    const { items } = await collectAsyncGenerated(
      this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }),
    );

    for (const spf of items) {
      if (matchesAnyGlob(spf.path)) {
        console.log(spf.contents);
      }
    }
  }

  async *materializeFs(
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      fs: string;
      destroyFirst?: boolean;
    },
  ) {
    const { fs } = opts;
    if (opts.destroyFirst) {
      try {
        await Deno.remove(fs, { recursive: true });
        console.info(`Removed ${fs}`);
      } catch (err) {
        if (!(err instanceof Deno.errors.NotFound)) {
          console.error(`Error while trying to remove ${fs}`, err);
        }
      }
    }
    for await (
      const spf of normalizeSPC(this.spn.sqlPageFiles({
        mdSources: opts.md,
        srcRelTo: opts.srcRelTo,
        state: sqlPagePlaybookState(),
      }))
    ) {
      const absPath = join(fs, spf.path);
      await ensureDir(dirname(absPath));
      await Deno.writeTextFile(absPath, spf.contents);
      yield { ...spf, absPath };
    }
  }

  async materializeFsWatch(
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      fs: string;
      destroyFirst?: boolean;
      watch?: boolean;
      verbose?: boolean;
      withSqlPage?: {
        enabled?: boolean;
        sitePrefix?: string;
      };
    },
  ) {
    const sidecars = opts.withSqlPage?.enabled
      ? [
        {
          name: "sqlpage",
          cmd: ["sqlpage"],
          env: {
            SQLPAGE_SITE_PREFIX: opts.withSqlPage?.sitePrefix ?? "",
            ...Deno.env.toObject(),
          },
          shutdownSignal: "SIGTERM",
          shutdownTimeoutMs: 1500,
        } satisfies SidecarOpts,
      ]
      : undefined;

    const bus = eventBus<WatcherEvents>();
    const run = watcher(
      opts.md,
      async () => {
        for await (const spf of this.materializeFs(opts)) {
          if (opts.verbose) console.log(spf.path);
        }
      },
      {
        debounceMs: 120,
        recursive: false,
        bus,
        sidecars,
      },
    );

    // Example listeners (optional)
    bus.on(
      "run:begin",
      (ev) =>
        console.log(
          `[watch] build ${ev.runIndex} begin with SQLPage: ${
            opts.withSqlPage?.enabled ?? "no"
          }`,
        ),
    );
    bus.on("run:success", () => console.log("[watch] build success"));
    bus.on(
      "run:error",
      ({ error }) => console.error("[watch] build error:", error),
    );

    await run(opts.watch);
  }

  command(name = "spry.ts") {
    // Enum type with enum.
    const srcRelTo = new EnumType(SourceRelativeTo);
    const mdOpt = [
      "-m, --md <mdPath:string>",
      "Use the given Markdown source(s), multiple allowed",
      {
        required: true,
        collect: true,
        default: ["Spryfile.md"],
      },
    ] as const;
    const srcRelToOpt = [
      "--src-rel-to <relative-to:sourceRelTo>",
      "When relative paths are used, what are they relative to?",
      {
        default: SourceRelativeTo.LocalFs,
      },
    ] as const;

    return new Command()
      .name(name)
      .version("0.1.0")
      .description(
        "SQLPage Markdown Notebook: emit SQL package, write sqlpage.json, or materialize filesystem.",
      )
      .command("help", new HelpCommand().global())
      .command("doctor", "Show dependencies and their availability")
      .action(async () => {
        const diags = doctor(["deno --version", "sqlpage --version"]);
        const result = await diags.run();
        diags.render.cli(result);
      })
      .command(
        "spc",
        new Command() // Emit SQL package (sqlite) to stdout; accepts md path
          .description("SQLPage Content (spc) CLI")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option(
            "-p, --package",
            "Emit SQL package (sqlite) to stdout from the given markdown path.",
            { conflicts: ["fs"] },
          )
          // Materialize files to a target directory
          .option(
            "--fs <srcHome:string>",
            "Materialize SQL files under this directory.",
            { conflicts: ["package"], depends: ["conf"] },
          )
          .option(
            "--destroy-first",
            "Remove the directory that --fs points to before materializing SQL files",
            { depends: ["fs"] },
          )
          .option(
            "--watch",
            "Materialize SQL files under this directory every time the markdown sources change",
            { depends: ["fs"] },
          )
          .option(
            "--with-sqlpage",
            "Start a local SQLPage binary in dev mode pointing to the --fs directory",
            { depends: ["watch"] },
          )
          // Write sqlpage.json to the given path
          .option(
            "-c, --conf <confPath:string>",
            "Write sqlpage.json to this path (generated from frontmatter sqlpage-conf).",
          )
          .option("--verbose", "Emit information messages")
          .action(async (opts) => {
            // If --fs is present, materialize files under that root
            if (typeof opts.fs === "string" && opts.fs.length > 0) {
              await this.materializeFsWatch({
                // not sure why this mapping is needed, Cliffy seems to not type `default` for `collect`ed arrays properly?
                md: opts.md.map((f) => String(f)),
                srcRelTo: opts.srcRelTo,
                fs: opts.fs,
                destroyFirst: opts.destroyFirst,
                verbose: opts.verbose,
                watch: opts?.watch,
                withSqlPage: { enabled: opts.withSqlpage },
              });
            }

            // If -p/--package is present (i.e., user requested SQL package), emit to stdout
            if (opts.package) {
              for (
                const chunk of await sqlPageFilesUpsertDML(
                  this.spn.sqlPageFiles({
                    mdSources: opts.md.map((f) => String(f)),
                    srcRelTo: opts.srcRelTo,
                    state: sqlPagePlaybookState(),
                  }),
                  {
                    dialect: "sqlite",
                    includeSqlPageFilesTable: true,
                  },
                )
              ) {
                console.log(chunk);
              }
            }

            // If --conf is present, write sqlpage.json
            if (opts.conf) {
              let emitted = 0, encountered = 0;
              const pp = await this.spn.populateContent({
                mdSources: opts.md.map((f) => String(f)),
                srcRelTo: opts.srcRelTo,
                state: sqlPagePlaybookState(),
              });
              for (const pb of pp.state.directives.playbooks) {
                encountered++;
                const { notebook: nb } = pb;
                if (nb.fm["sqlpage-conf"]) {
                  const json = sqlPageConf(nb.fm["sqlpage-conf"]);
                  // "web_root" should only be specified for `--fs`
                  // otherwise the directory won't exist
                  if (opts.package) delete json["web_root"];
                  await ensureDir(dirname(opts.conf));
                  await Deno.writeTextFile(
                    opts.conf,
                    JSON.stringify(json, null, 2),
                  );
                  if (opts.verbose) {
                    console.log(opts.conf);
                  }
                  emitted++;
                  break; // only pick from the first file
                }
              }
              if (emitted == 0) {
                console.warn(
                  `Encountered ${encountered} playbook(s) but no "sqlpage-conf" found in any frontmatter.`,
                );
              }
            }
          })
          .command("ls", "List SQLPage file entries")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("-t, --tree", "Show as tree")
          .action((opts) =>
            this.ls({
              ...opts,
              md: opts.md.map((f) => String(f)),
            })
          )
          .command("cat", "Concatenate SQLPage file contents")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("-g, --glob <path:string>", "Path glob(s) to target", {
            required: true,
            collect: true,
          })
          .action((opts) =>
            this.cat({
              ...opts,
              md: opts.md.map((f) => String(f)),
            })
          ),
      )
      .command(
        "task",
        new Command() // Emit SQL package (sqlite) to stdout; accepts md path
          .description(
            "Spry Task CLI (execute a specific cell and dependencies)",
          )
          .type("sourceRelTo", srcRelTo)
          .arguments("<taskId>")
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("--verbose", "Emit information messages")
          .option("--summarize", "Emit summary after execution in JSON")
          .action(async (opts, taskId) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            const runbook = await taskCLI.executeTasks(
              executionSubplan(
                executionPlan(
                  pp.state.directives.tasks.filter((t) =>
                    t.taskDirective.nature === "TASK"
                  ),
                ),
                [taskId],
              ),
              opts.verbose ? "rich" : false,
            );
            if (opts.summarize) {
              console.log(runbook);
            }
          })
          .command("ls", "List SQLPage file entries")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option(
            "-c, --content",
            "List CONTENT cells in addition to executables",
          )
          .action(async (opts) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            taskCLI.ls(
              opts.content
                ? pp.state.directives.tasks
                : pp.state.directives.tasks.filter((t) =>
                  t.taskDirective.nature === "TASK"
                ),
            );
          }),
      ).command(
        "runbook",
        new Command() // Emit SQL package (sqlite) to stdout; accepts md path
          .description("Spry Runbook CLI (execute all cells in DAG order)")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .option("--verbose", "Emit information messages verbosely")
          .option("--summarize", "Emit summary after execution in JSON")
          .action(async (opts) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            const runbook = await taskCLI.executeTasks(
              executionPlan(
                pp.state.directives.tasks.filter((t) =>
                  t.taskDirective.nature === "TASK"
                ),
              ),
              opts.verbose ? "rich" : false,
            );
            if (opts.summarize) {
              console.log(runbook);
            }
          })
          .command("ls", "List SQLPage file runbook entries")
          .type("sourceRelTo", srcRelTo)
          .option(...mdOpt)
          .option(...srcRelToOpt)
          .action(async (opts) => {
            const pp = await this.spn.populateContent({
              mdSources: opts.md.map((f) => String(f)),
              srcRelTo: opts.srcRelTo,
              state: sqlPagePlaybookState(),
            });
            taskCLI.ls(
              pp.state.directives.tasks.filter((t) =>
                t.taskDirective.nature === "TASK"
              ),
            );
          }),
      );
  }

  async run(argv: string[] = Deno.args, name = "spry.ts") {
    await this.command(name).parse(argv);
  }

  static instance() {
    return new CLI();
  }
}
